* Chapter 0

Page 1: features are not always known. Sometimes some of them are unknown, and get predicted (i.e. online systems).

If the book is more about implementing successful ML systems, using Reactive technologies, maybe it should be stresses more.

** Concepts
Probably the concepts are introduced too fast. I think it would be better if the author describes a typical machine learning system from the outside, defining the concepts based on that example.
The reader probably won't go back frequently to chapter 0 to clarify terminology. And in that case, the reader could be overwhelmed for nothing.

** Ready or not
This section is fine. However, the content helps clarifying what the reader needs to known, but it doesn't anticipate what will be the reward. The reader will probably want to know what she will be able to do after reading the book.

* Chapter 1

** An example machine learning system

Great chapter, since it allows the reader to follow an approach that seemed reasonable, and helps him discover the problems afterwards.

Page 9: Is Figure 1.5 / LibSVM actually Figure 4? Is it helpful to mention LibSVM here?

Last paragraph of Machine Learning section is great.

** When not to use reactive machine learning

The last paragraph came unexpected to me. After the Coursera Machine Learning course, we were taught to build prototypes before attempting to implement a real ML system.
I assume there will be a number of readers with the same background. While I see the point of suggesting not following the reactive path when building temporary ML systems,
does that mean that this book makes sense when you have already built a prototype, and are thinking of building a real ML application?

I think it would be interesting to show a simple SWOT or recipe diagram, e.g.:

| scope                   | Target system | Technologies                              |
|-------------------------+---------------+-------------------------------------------|
| learning about the data | prototype     | Octave, Matlab, R, Weka, ...              |
| Building a ML system    | production    | Home-grown, reactive-based implementation |

** Summary

There's a bullet enumerating the 5 components of a ML system, but they're not explained in chapter 1.

* Chapter 2

*** Listing 2.3

In Listing 2.3, I got an unexpected result, probably due to misunderstanding on my part.
I wanted to test the method Map.withDefaultValue(), but I got an unexpected result.
Here's my code:

#+BEGIN_SRC java
object HelloWorld {

   val totalVotes = Map("Mickey" -> 52, "nom nom" -> 105)
   val totalVotesWithDefault = Map("Mikey" -> 52, "nom nom" -> 105).withDefaultValue(-1)
   val naiveNomNomVotes: Option[Int] = totalVotesWithDefault.get("nom nom")

   def getVotes(howler: String) = {
       totalVotesWithDefault.get(howler) match {
           case Some(votes) => votes
           case None => 0
       }
   }

   def main(args: Array[String]) {
      val nomNomVotes: Int = getVotes("nom nom")
      val indianaVotes: Int = getVotes("Indiana")
      println(nomNomVotes)
      println(indianaVotes)
   }
}
#+END_SRC

Instead of 105, -1, it prints 105, 0.

*** Listing 2.4

In listing 2.4, I got an issue as well, probably because I was using an online editor (https://www.tutorialspoint.com/compile_scala_online.php):
The compiler didn't accept calling the static method "nextInt" directly, so I had to instantiate a new Random instance.

#+BEGIN_SRC java
       Thread.sleep(new java.util.Random().nextInt(1000))
#+END_SRC

instead of

#+BEGIN_SRC java
       Thread.sleep(Random.nextInt(1000))
#+END_SRC

*** Listing 2.5

I had to use a Thread.sleep(1000) in order to see the "The top dog currently has ...".
Keep in mind the message is not formatted correctly (it says "The tog dog currently has105votes.").

The text points out using futures provides benefits in terms of scaling, but I think it's not the
key point of using futures. Instead, it's simplifying writing asynchronous code, making it seem synchronous, and leveraging multi-core architectures.
But it's not really the silver bullet of scaling. You'll probably need to check how many concurrent threads are spawned, and for how long they live.

*** Listing 2.6

Again, it's probably my fault, but I get a compile error. Here's the code I was trying to compile:

#+BEGIN_SRC java
import scala.concurrent._
import ExecutionContext.Implicits.global

object HelloWorld {

   val totalVotesWithDefault = Map("Mikey" -> 52, "nom nom" -> 105).withDefaultValue(0)

   def getRemoteVotes(howler: String) = {
       Thread.sleep(new java.util.Random().nextInt(1000))
       totalVotesWithDefault(howler)
   }

   def futureRemoteVotes(howler: String) = Future {
       getRemoteVotes(howler)
   }


   val timeoutDuration = 500
   val AverageVotes = 42

   val defaultVotes = Future {
       Thread.sleep(timeoutDuration)
       AverageVotes
   }

   def timeoutVotes(howler: String) = Future.firstCompletedOf(
         List(getRemoteVotes(howler), defaultVotes))

   def main(args: Array[String]) {

     val nomNomFutureVotes = futureRemoteVotes("nom nom")
     val mikeyFutureVotes = futureRemoteVotes("Mikey")
     val indianaFutureVotes = futureRemoteVotes("Indiana")

     val topDogVotes: Future[Int] = for {
       nomNom <- nomNomFutureVotes
       mikey <- mikeyFutureVotes
       indiana <- indianaFutureVotes
     } yield List(nomNom, mikey, indiana).max

     topDogVotes onSuccess {
       case _ => println("The top dog currently has " + topDogVotes + " votes")
     }

     Thread.sleep(10000)
  }
}
#+END_SRC

The error I get is

#+BEGIN_SRC shell
sh-4.3$ scalac *.scala
HelloWorld.scala:27: error: type mismatch;
 found   : List[Any]
 required: TraversableOnce[scala.concurrent.Future[?]]
         List(getRemoteVotes(howler), defaultVotes))
#+END_SRC

*** Listing 2.7

I had to explicitly qualify "mutable" as "scala.collection.mutable" when creating the HashMap.

*** Listing 2.9

I had to qualify "Actor" as "akka.actor.Actor".

*** Listing 2.13

It seems the training files are available from a repository, but it doesn't mention Appendix A.

In page 26, I think the difference between training set and test samples is not clear enough.
Particularly, the reader might not know which data could be used for testing instead of training the system.

* Chapter 3

In general, I liked the storytelling: describing the problem, proposing a typical solution, describing why it doesn't fit, and proposing an alternate approach.

However, once the synchronous solution is discarded, the solution proposed is like: let's see what databases are out there and which characteristics can be helpful in this context.
I'd find more rigorous to use a scientific approach. Each step, from data gathering to data consumption, analyze the same set of facts: does it scale? does it lose information? Were are the bottlenecks, if any?
It'd be the same story, but without the sense of "I'd probably would choose another option at first". In other words, what if the reader is not familiar with reactive concepts and products? What if
the reader doesn't know he doesn't know? In that case, proposing Couchbase out of the blue is probably something he won't do, because his experience won't guide him towards that path.
Not to mention if he works for a corporation and proposing Couchbase would mean a fight ahead.

As a side note, in the source code examples I'd reword the "Readings" variables, because most of the chapter involves actually *writing* them. Maybe using "Samples" or "Examples" would avoid any potential confusion.

* Chapter 4

In general, the chapter is several things at once:
- Introduction to chapter 5.
- Advises on how to face common challenges when dealing with features.
- Source code samples used to address issues related with features, showing some helpful Scala idioms.

I've had some problems trying to following the author. I found myself thinking where I was in the whole picture of the book.
Chapter 3 was great because the problem was easy to understand, and the solution was easy to follow. The storyline was clear.
This chapter is an information transfer, not a knowledge transfer. The reader cannot do much more than not get lost, and remind himself to get back to that chapter in the future, once he faces the issues the chapter describes.
In particular, I'd leverage the chapter to make sure the reader knows what features are all about. I'd mention the problem of underfitting and overfitting. I had problems to see how I could choose features without analyzing the performance and accuracy of the ML system. I think that concerns could be addressed briefly.
It would help also to recall where we are in the journey towards building a ML system. I liked the summary, because I was aware again of why this chapter was necessary. Meanwhile, while the content was interesting, I think I was missing the point all too frequently.

